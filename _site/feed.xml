<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-04T00:15:06-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Zimu Huo / Personal Site</title><subtitle>personal description</subtitle><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><entry><title type="html">Burst imaging simulation</title><link href="http://localhost:4000/posts/blog-post-22/" rel="alternate" type="text/html" title="Burst imaging simulation" /><published>2024-09-10T00:00:00-07:00</published><updated>2024-09-10T00:00:00-07:00</updated><id>http://localhost:4000/posts/blog-post-22</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-22/"><![CDATA[<p>An ultrafast excitation and acquisition technique.</p>

<p>This demo demonstrates how you can implement a sequence with just a few lines of code (in under 10 seconds) and visualize both the EPG and isochromat simulations with my simulation toolbox</p>

<p><a href="../notebooks/burst.html">View the BURST demo here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Sequence" /><category term="Burst" /><summary type="html"><![CDATA[An ultrafast excitation and acquisition technique. This demo demonstrates how you can implement a sequence with just a few lines of code (in under 10 seconds) and visualize both the EPG and isochromat simulations with my simulation toolbox View the BURST demo here]]></summary></entry><entry><title type="html">Simulatenous Mulit-slice reconstruction tutorial 5</title><link href="http://localhost:4000/posts/blog-post-21/" rel="alternate" type="text/html" title="Simulatenous Mulit-slice reconstruction tutorial 5" /><published>2024-05-10T00:00:00-07:00</published><updated>2024-05-10T00:00:00-07:00</updated><id>http://localhost:4000/posts/blog-post-21</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-21/"><![CDATA[<p>The slice-leakage is an artefact where the information from one slice is unintentionally transmitted to another slice during reconstruction. Any information from slice A that appears in slice B at the end of the reconstruction is considered slice leakage. The current method involves using a Monte Carlo simulation to impose unique frequency modulations on each slice. After reconstructions, the slice leakage can be determined by quantifying the frequency modulations on each individual slice. For example, if we add a 4 Hz modulation on slice A and a 6 Hz modulation on slice B, any 6 Hz component found on slice A after the reconstruction could be used to indicate slice leakage.</p>

<p><a href="../notebooks/slice_leakagedemo.html">View the SMS tutorial 5 here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Reconstruction" /><category term="SMS" /><summary type="html"><![CDATA[The slice-leakage is an artefact where the information from one slice is unintentionally transmitted to another slice during reconstruction. Any information from slice A that appears in slice B at the end of the reconstruction is considered slice leakage. The current method involves using a Monte Carlo simulation to impose unique frequency modulations on each slice. After reconstructions, the slice leakage can be determined by quantifying the frequency modulations on each individual slice. For example, if we add a 4 Hz modulation on slice A and a 6 Hz modulation on slice B, any 6 Hz component found on slice A after the reconstruction could be used to indicate slice leakage. View the SMS tutorial 5 here]]></summary></entry><entry><title type="html">NUFFT tutorial</title><link href="http://localhost:4000/posts/blog-post-20/" rel="alternate" type="text/html" title="NUFFT tutorial" /><published>2024-04-10T00:00:00-07:00</published><updated>2024-04-10T00:00:00-07:00</updated><id>http://localhost:4000/posts/blog-post-20</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-20/"><![CDATA[<p>Challenges arise when reconstructing from non-uniform sampling patterns in the Fourier domain. Performing a direct Fourier transform in such cases incurs a quadratic computation cost of O($N^2$), rendering it impractical for standard practices at high resolutions. This requires transforming non-Cartesian samples back into a uniformly spaced Cartesian grid, enabling the utilization of more efficient FFT algorithms. Typical regridding procedures involve convolving the acquired data with a predefined gridding kernel weighted by the pre-calculated density compensation function, followed by a resampling process onto the Cartesian grid. The ideal gridding kernel is a sinc function, as its Fourier transform results in a rectangular function. However, since the optimal convolution function is of infinite extent, implementing it directly is impractical. To address this, the convolution kernel is truncated and windowed. A popular choice for this purpose is the use of Kaiser-Bessel functions. These methodologies are commonly known as “gridding” and is a special case of non-uniform Fourier transforms (NUFFT).</p>

<p><a href="../notebooks/gridding.html">View the NUFFT tutorial here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Reconstruction" /><category term="NUFFT" /><summary type="html"><![CDATA[Challenges arise when reconstructing from non-uniform sampling patterns in the Fourier domain. Performing a direct Fourier transform in such cases incurs a quadratic computation cost of O($N^2$), rendering it impractical for standard practices at high resolutions. This requires transforming non-Cartesian samples back into a uniformly spaced Cartesian grid, enabling the utilization of more efficient FFT algorithms. Typical regridding procedures involve convolving the acquired data with a predefined gridding kernel weighted by the pre-calculated density compensation function, followed by a resampling process onto the Cartesian grid. The ideal gridding kernel is a sinc function, as its Fourier transform results in a rectangular function. However, since the optimal convolution function is of infinite extent, implementing it directly is impractical. To address this, the convolution kernel is truncated and windowed. A popular choice for this purpose is the use of Kaiser-Bessel functions. These methodologies are commonly known as “gridding” and is a special case of non-uniform Fourier transforms (NUFFT). View the NUFFT tutorial here]]></summary></entry><entry><title type="html">bSSFP simulation tutorial 2</title><link href="http://localhost:4000/posts/blog-post-19/" rel="alternate" type="text/html" title="bSSFP simulation tutorial 2" /><published>2024-02-10T00:00:00-08:00</published><updated>2024-02-10T00:00:00-08:00</updated><id>http://localhost:4000/posts/blog-post-19</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-19/"><![CDATA[<p>Here, I present various variations of bSSFP: standard bSSFP, fluctuating equilibrium, and alternating steady states. Each variation manipulates sequence parameters such as TR, flip angles, and RF phase to generate unique profiles optimized for specific tasks.</p>

<p><a href="../notebooks/ssfp_demo1.html">View the SSFP tutorial 2 here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Signal Model" /><category term="SSFP" /><summary type="html"><![CDATA[Here, I present various variations of bSSFP: standard bSSFP, fluctuating equilibrium, and alternating steady states. Each variation manipulates sequence parameters such as TR, flip angles, and RF phase to generate unique profiles optimized for specific tasks. View the SSFP tutorial 2 here]]></summary></entry><entry><title type="html">bSSFP simulation tutorial 1</title><link href="http://localhost:4000/posts/blog-post-18/" rel="alternate" type="text/html" title="bSSFP simulation tutorial 1" /><published>2024-02-01T00:00:00-08:00</published><updated>2024-02-01T00:00:00-08:00</updated><id>http://localhost:4000/posts/blog-post-18</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-18/"><![CDATA[<p>In bSSFP, the entire spin evolution can be modeled mathematically through bloch equations, which can be broken down into three components: excitation E, relaxation R, and precession P. These three components are matrix operators representing the sequence events. Immediately after the RF pulse R, the spin undergoes T1 and T2 relaxation E and off-resonance precession P. The bSSFP sequence achieves the steady state by repetitively executing these operations, while ensuring that the gradients are refocused within each TR.</p>

<p><a href="../notebooks/ssfp_demo2.html">View the SSFP tutorial 1 here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Signal Model" /><category term="SSFP" /><summary type="html"><![CDATA[In bSSFP, the entire spin evolution can be modeled mathematically through bloch equations, which can be broken down into three components: excitation E, relaxation R, and precession P. These three components are matrix operators representing the sequence events. Immediately after the RF pulse R, the spin undergoes T1 and T2 relaxation E and off-resonance precession P. The bSSFP sequence achieves the steady state by repetitively executing these operations, while ensuring that the gradients are refocused within each TR. View the SSFP tutorial 1 here]]></summary></entry><entry><title type="html">Partial Fourier reconstruction tutorial 3</title><link href="http://localhost:4000/posts/blog-post-17/" rel="alternate" type="text/html" title="Partial Fourier reconstruction tutorial 3" /><published>2023-04-17T00:00:00-07:00</published><updated>2023-04-17T00:00:00-07:00</updated><id>http://localhost:4000/posts/blog-post-17</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-17/"><![CDATA[<p>Partial Fourier techniques aim to recover missing data using only half of the k-space. This reconstruction leverages the conjugate symmetry property of k-space, although it is sensitive to phase errors.</p>

<p>Here, I present a Homodyne reconstruction that employs a more signal processing-oriented approach. It treats undersampling as a filter with different weightings for various frequency components in k-space, and attempts to apply the inverse of the filter to reverse the process.</p>

<p><a href="../notebooks/homodyne.html">View the Partial Fourier tutorial 3 here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Reconstruction" /><category term="Partial Fourier" /><summary type="html"><![CDATA[Partial Fourier techniques aim to recover missing data using only half of the k-space. This reconstruction leverages the conjugate symmetry property of k-space, although it is sensitive to phase errors. Here, I present a Homodyne reconstruction that employs a more signal processing-oriented approach. It treats undersampling as a filter with different weightings for various frequency components in k-space, and attempts to apply the inverse of the filter to reverse the process. View the Partial Fourier tutorial 3 here]]></summary></entry><entry><title type="html">Partial Fourier reconstruction tutorial 2</title><link href="http://localhost:4000/posts/blog-post-16/" rel="alternate" type="text/html" title="Partial Fourier reconstruction tutorial 2" /><published>2023-04-16T00:00:00-07:00</published><updated>2023-04-16T00:00:00-07:00</updated><id>http://localhost:4000/posts/blog-post-16</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-16/"><![CDATA[<p>Partial Fourier techniques aim to recover missing data using only half of the k-space. This reconstruction leverages the conjugate symmetry property of k-space, although it is sensitive to phase errors.</p>

<p>Here, I present a Projection onto Convex Sets (POCS) algorithm that finds the optimal solution by considering two criteria: 1. consistency with the acquired phase, and 2. consistency with the acquired k-space data.</p>

<p><a href="../notebooks/POCS.html">View the Partial Fourier tutorial 2 here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Reconstruction" /><category term="Partial Fourier" /><summary type="html"><![CDATA[Partial Fourier techniques aim to recover missing data using only half of the k-space. This reconstruction leverages the conjugate symmetry property of k-space, although it is sensitive to phase errors. Here, I present a Projection onto Convex Sets (POCS) algorithm that finds the optimal solution by considering two criteria: 1. consistency with the acquired phase, and 2. consistency with the acquired k-space data. View the Partial Fourier tutorial 2 here]]></summary></entry><entry><title type="html">Partial Fourier reconstruction tutorial 1</title><link href="http://localhost:4000/posts/blog-post-15/" rel="alternate" type="text/html" title="Partial Fourier reconstruction tutorial 1" /><published>2023-04-15T00:00:00-07:00</published><updated>2023-04-15T00:00:00-07:00</updated><id>http://localhost:4000/posts/blog-post-15</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-15/"><![CDATA[<p>Partial Fourier techniques aim to recover missing data using only half of the k-space. This reconstruction leverages the conjugate symmetry property of k-space, although it is sensitive to phase errors.</p>

<p>Here, I present a straightforward reconstruction method based on the conjugate symmetry of k-space</p>

<p><a href="../notebooks/conjugateSynthesis.html">View the Partial Fourier tutorial 1 here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Reconstruction" /><category term="Partial Fourier" /><summary type="html"><![CDATA[Partial Fourier techniques aim to recover missing data using only half of the k-space. This reconstruction leverages the conjugate symmetry property of k-space, although it is sensitive to phase errors. Here, I present a straightforward reconstruction method based on the conjugate symmetry of k-space View the Partial Fourier tutorial 1 here]]></summary></entry><entry><title type="html">Low Rank reconstruction tutorial</title><link href="http://localhost:4000/posts/blog-post-14/" rel="alternate" type="text/html" title="Low Rank reconstruction tutorial" /><published>2023-04-10T00:00:00-07:00</published><updated>2023-04-10T00:00:00-07:00</updated><id>http://localhost:4000/posts/blog-post-14</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-14/"><![CDATA[<p>The low rank based method will recover the missing data by enforcing self-consistency among neighboring k-space points in Cartesian space when minimizing the rank of the structured Hankel matrix. The self-consistency refers to the annihilation relationship being satisfied for all locations in k-space. Directly solving rank problems is computationally challenging and falls under the category of NP-hard problems. To address this, the non-convex rank function is replaced with its convex relaxation, which is replacing the non-convex rank function with its convex approximation, known as the nuclear norm.</p>

<p><a href="../notebooks/PLOARKS_demo_new.html">View the Low Rank tutorial here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Reconstruction" /><category term="Low Rank" /><summary type="html"><![CDATA[The low rank based method will recover the missing data by enforcing self-consistency among neighboring k-space points in Cartesian space when minimizing the rank of the structured Hankel matrix. The self-consistency refers to the annihilation relationship being satisfied for all locations in k-space. Directly solving rank problems is computationally challenging and falls under the category of NP-hard problems. To address this, the non-convex rank function is replaced with its convex relaxation, which is replacing the non-convex rank function with its convex approximation, known as the nuclear norm. View the Low Rank tutorial here]]></summary></entry><entry><title type="html">Simulatenous Mulit-slice reconstruction tutorial 4</title><link href="http://localhost:4000/posts/blog-post-13/" rel="alternate" type="text/html" title="Simulatenous Mulit-slice reconstruction tutorial 4" /><published>2023-04-02T00:00:00-07:00</published><updated>2023-04-02T00:00:00-07:00</updated><id>http://localhost:4000/posts/blog-post-13</id><content type="html" xml:base="http://localhost:4000/posts/blog-post-13/"><![CDATA[<p>The slice grappa tries to reduce the total artefact without placing constraints on the intraslice and interslice artifacts. So the artefacts can be arbitrarily large(like vectors pointing in opposite directions can cancel out each other, also called artefact cancellation). The split slice trades interslice artefact with intraslice artefact (lower interslice artefact and higher intraslice artefact) by forming a “correlation matrix” that contrains the interslice leakage to be minimum.</p>

<p><a href="../notebooks/spsliceGrappa.html">View the split slice slice GRAPPA tutorial here</a></p>]]></content><author><name>Zimu Huo</name><email>zh382@cam.ac.uk</email></author><category term="MRI" /><category term="Reconstruction" /><category term="SMS" /><summary type="html"><![CDATA[The slice grappa tries to reduce the total artefact without placing constraints on the intraslice and interslice artifacts. So the artefacts can be arbitrarily large(like vectors pointing in opposite directions can cancel out each other, also called artefact cancellation). The split slice trades interslice artefact with intraslice artefact (lower interslice artefact and higher intraslice artefact) by forming a “correlation matrix” that contrains the interslice leakage to be minimum. View the split slice slice GRAPPA tutorial here]]></summary></entry></feed>